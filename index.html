<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crab Simulator</title>
    <style>
        /* Basic reset to make the game full screen */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            cursor: crosshair; /* Helps to see the cursor position */
        }

        #game-area {
            overflow: hidden;
            user-select: none;
            width: 100%;
            height: 100%;
            position: relative; /* Needed to position the 'world' inside */
            background-color: #D2B48C; /* A sand-like fallback color */
        }

        #world {
            position: absolute;
            width: 20480px; /* Increased size */
            height: 20480px; /* Increased size */
            background-image: url('sand.png'); /* Placeholder */
            background-repeat: repeat;
            transform-style: preserve-3d;
            will-change: transform;
        }

        /* New overlay for light and shade with passing cloud effect */
        #light-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(
                ellipse at center,
                rgba(16, 32, 48, 0.0) 0%,
                rgba(16, 32, 48, 0.8) 70%,
                rgba(16, 32, 48, 0.8) 100%
            );
            background-size: 400% 400%; /* Large size to create a soft, wide shadow */
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 200; /* Above everything except tutorial text */
            opacity: 1; /* Start dark */
            transition: opacity 5s ease-in-out; /* Smooth transition */
        }

        /* --- Seaweed Styling --- */
        .seaweed {
            position: absolute;
            width: 246px;
            height: 430px;
            background-image: url('seaweed.png'); /* Placeholder */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            opacity: 0.8;
            transform-origin: bottom center;
            animation: sway 6s ease-in-out infinite;
            z-index: 150; /* Set a higher z-index to appear in front of the crab */
        }

        /* --- Crab Styling --- */
        .crab { /* Changed from #crab to a class for reusability */
            position: absolute;
            width: 281px;
            height: 196px;
            z-index: 100; /* Crab is on a lower layer than the seaweed */
            transform-origin: center center;
            will-change: transform, left, top;
        }

        .crab-part {
            position: absolute;
        }

        .crab-body { /* Changed from #crab-body */
            width: 100%;
            height: 100%;
            background-image: url('crab.png'); /* Placeholder */
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 10;
        }
        
        /* --- Simplified Arm Styling (Debug Placeholders) --- */
        .arm {
            width: 57px;
            height: 82px;
            transform-origin: top center;
            top: 170px;
            z-index: 5; 
        }

        .right-arm { /* Changed from #right-arm */
            background-image: url('rightarm.png');
            background-size: contain;
            background-repeat: no-repeat;
            left: 25px;
        }
        
        .left-arm { /* Fix: Corrected the left position */
            background-image: url('leftarm.png');
            background-size: contain;
            background-repeat: no-repeat;
            left: 200px;
        }
       
        .right-claw { /* Changed from #right-claw */
            width: 197px;
            height: 77px;
            background-image: url('rightopen.png');
            background-size: contain;
            background-repeat: no-repeat;
            transform-origin: top left; /* Pivot from corner */
            top: 82px; /* Positioned at the bottom of the arm */
            left: calc(57px / 2); /* Position pivot at arm's center */
            z-index: 6; /* On top of the arm */
        }

        .left-claw { /* Changed from #left-claw */
            width: 197px;
            height: 77px;
            background-image: url('leftopen.png');
            background-size: contain;
            background-repeat: no-repeat;
            transform-origin: top right; /* Pivot from corner */
            top: 82px; /* Positioned at the bottom of the arm */
            left: calc(57px / 2 - 197px); /* Position pivot at arm's center */
            z-index: 6; /* On top of the arm */
        }
        
        .severed-claw {
            z-index: 5; /* Above sand, below other crabs */
        }

        /* --- Tutorial Elements --- */
        #subtitle {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            color: black;
            font-family: 'High Tower Text', serif;
            font-style: italic;
            font-size: 24px;
            transition: opacity 1s ease-in-out;
            z-index: 200;
            pointer-events: none; /* So it doesn't block clicks */
        }

        #hermit-character {
            position: absolute;
            /* No longer positioned relative to the screen */
            width: 182px;
            height: 152px;
            background-image: url('hermit.png');
            background-size: contain;
            background-repeat: no-repeat;
            transition: opacity 1s ease-in-out;
            z-index: 95; /* Below crab, above sand objects */
            pointer-events: none;
        }

        .shell {
            position: absolute;
            width: 182px; /* Same size as hermit for consistency */
            height: 152px;
            background-image: url('shell.png');
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 90; /* Below the crab but above the sand */
            transition: opacity 1s ease-in-out;
            /* Added a padding to increase clickable area */
            padding: 20px;
        }

        /* --- Animations --- */
        @keyframes sway {
            0%, 100% { transform: rotateZ(-5deg); }
            50% { transform: rotateZ(5deg); }
        }
    </style>
</head>
<body>
    <div id="game-area">
        <div id="world">
            </div>
        <div id="subtitle"></div>
        <div id="light-overlay"></div>
    </div>

    <script>
        const gameArea = document.getElementById('game-area');
        const world = document.getElementById('world');
        const lightOverlay = document.getElementById('light-overlay');
        const seaweedCount = 12;
        const worldSize = 20480;

        let crab = null;
        let hermitCharacter, subtitle;

        // Pilgrim NPCs
        let pilgrims = [];

        // Arm part references
        let rightArm, rightClawEl;
        let leftArm, leftClawEl;
        
        // --- Game State ---
        let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let mouseState = { leftDown: false, rightDown: false };
        let activeControl = 'none'; // 'none', 'left', 'right'
        let leftClawClosed = false;
        let rightClawClosed = false;
        
        let tutorialState = {
            leftClicked: false,
            rightClicked: false,
            movementExplained: false
        };

        let crabState = {
            x: worldSize / 2,
            y: worldSize / 2,
            angle: 0,
            width: 281,
            height: 196,
            scale: 1.0, // For growth mechanic
            rightArmAngle: 0,
            leftArmAngle: 0,
            rightClawAngle: 0,
            leftClawAngle: 0,
            friends: [],
            isDancing: false,
            hasLeftArm: true,
            hasRightArm: true,
            domElements: {}, // For player crab elements
            heldClaw: null,
            eatTimer: 0
        };
        let camera = {
            x: 0,
            y: 0,
            zoom: 0.8,
            minZoom: Math.min(window.innerWidth / worldSize, window.innerHeight / worldSize),
            maxZoom: 1.2
        };

        let lightCycleTimer = 0;
        let lastTimestamp = 0;

        // --- Event Listeners ---
        window.addEventListener('mousemove', (event) => {
            mouse.x = event.clientX;
            mouse.y = event.clientY;
        });

        window.addEventListener('wheel', (event) => {
            const zoomSpeed = 0.05;
            if (event.deltaY > 0) camera.zoom -= zoomSpeed;
            else camera.zoom += zoomSpeed;
            camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, camera.zoom));
        });

        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Left click
                mouseState.leftDown = true;
                tutorialState.leftClicked = true;
                if ((activeControl === 'left' || (mouseState.leftDown && mouseState.rightDown)) && crabState.hasLeftArm) {
                    leftClawClosed = !leftClawClosed;
                    if (leftClawClosed) {
                        checkForPlayerAttack(leftClawEl);
                        checkForClawPickup(leftClawEl, 'left');
                    } else { // Claw is now open, so drop what's held
                        if (crabState.heldClaw && crabState.heldClaw.holdingHand === 'left') {
                            dropHeldClaw();
                        }
                    }
                } else {
                    activeControl = 'left';
                }
            } else if (event.button === 2) { // Right click
                mouseState.rightDown = true;
                tutorialState.rightClicked = true;
                 if ((activeControl === 'right' || (mouseState.leftDown && mouseState.rightDown)) && crabState.hasRightArm) {
                    rightClawClosed = !rightClawClosed;
                    if(rightClawClosed) {
                        checkForPlayerAttack(rightClawEl);
                        checkForClawPickup(rightClawEl, 'right');
                    } else { // Claw is now open, so drop what's held
                        if (crabState.heldClaw && crabState.heldClaw.holdingHand === 'right') {
                            dropHeldClaw();
                        }
                    }
                } else {
                    activeControl = 'right';
                }
            }
            updateClawImages();

            if (tutorialState.leftClicked && tutorialState.rightClicked && !tutorialState.movementExplained) {
                startMovementTutorial();
            }
        });

        window.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                mouseState.leftDown = false;
            }
            else if (event.button === 2) {
                mouseState.rightDown = false;
            }
        });


        window.addEventListener('contextmenu', (event) => event.preventDefault());
        
        window.onload = function() {
            subtitle = document.getElementById('subtitle');
            subtitle.textContent = 'right mouse button for right claw, left mouse button for left claw.';
            
            createSeaweed();
            createCrab();

            hermitCharacter = document.createElement('div');
            hermitCharacter.id = 'hermit-character';
            const hermitWidth = 182;
            const hermitHeight = 152;
            const hermitX = crabState.x - hermitWidth / 2;
            const hermitY = crabState.y - crabState.height / 2 - hermitHeight - 50; 
            hermitCharacter.style.left = `${hermitX}px`;
            hermitCharacter.style.top = `${hermitY}px`;
            world.appendChild(hermitCharacter);
            
            gameLoop(0); 
        };

        const imageUrls = {
            leftOpen: 'leftopen.png',
            leftClosed: 'leftclosed.png',
            rightOpen: 'rightopen.png',
            rightClosed: 'rightclosed.png',
            hermit: 'hermit.png',
            shell: 'shell.png'
        };

        function updateClawImages() {
            if (crabState.hasLeftArm) leftClawEl.style.backgroundImage = `url('${leftClawClosed ? imageUrls.leftClosed : imageUrls.leftOpen}')`;
            if (crabState.hasRightArm) rightClawEl.style.backgroundImage = `url('${rightClawClosed ? imageUrls.rightClosed : imageUrls.rightOpen}')`;
        }
        
        function startMovementTutorial() {
            tutorialState.movementExplained = true; 
            subtitle.textContent = 'move the cursor and your crab will follow.';

            setTimeout(() => {
                subtitle.textContent = 'use the mouse wheel to zoom in and out.';
                setTimeout(() => {
                    subtitle.style.opacity = '0';
                    hermitCharacter.style.backgroundImage = `url('${imageUrls.shell}')`;
                    setTimeout(() => {
                        hermitCharacter.style.opacity = '0';
                        setTimeout(spawnRandomShell, 1000); 
                    }, 4000);
                }, 4000);
            }, 4000);
        }

        function handleShellClick(event) {
            const clickedShell = event.currentTarget;
            clickedShell.style.backgroundImage = `url('${imageUrls.hermit}')`;
            subtitle.style.opacity = '1';
            subtitle.textContent = 'the rock pool is a mirror of your own.';

            setTimeout(() => { subtitle.textContent = 'whatever you do is echoed back to you.'; }, 4000);
            setTimeout(() => {
                subtitle.style.opacity = '0';
                clickedShell.style.backgroundImage = `url('${imageUrls.shell}')`;
                setTimeout(() => {
                    clickedShell.style.opacity = '0';
                    setTimeout(() => {
                        clickedShell.remove();
                        spawnPilgrimCrab();
                        spawnThirdShell(); 
                    }, 1000);
                }, 4000);
            }, 8000);
        }

        function handleThirdShellClick(event) {
            const clickedShell = event.currentTarget;
            clickedShell.style.backgroundImage = `url('${imageUrls.hermit}')`;
            subtitle.style.opacity = '1';
            subtitle.textContent = 'the sand too, that you tread, was once you';

            setTimeout(() => {
                subtitle.style.opacity = '0';
                clickedShell.style.backgroundImage = `url('${imageUrls.shell}')`;
                setTimeout(() => {
                    clickedShell.style.opacity = '0';
                    setTimeout(() => {
                        clickedShell.remove();
                        spawnPilgrimCrab();
                        spawnPilgrimCrab();
                        spawnSeventhShell();
                    }, 1000);
                }, 4000);
            }, 4000);
        }

        function handleSeventhShellClick(event) {
            const clickedShell = event.currentTarget;
            clickedShell.style.backgroundImage = `url('${imageUrls.hermit}')`;
            subtitle.style.opacity = '1';
            subtitle.textContent = 'crabs consider dancing two buttons down.';

            setTimeout(() => { subtitle.textContent = 'your friends will also dance.'; }, 4000);
            setTimeout(() => { subtitle.textContent = 'if wanderers are close enough, they will dance also and regard you as friend.'; }, 8000);
            setTimeout(() => {
                subtitle.style.opacity = '0';
                clickedShell.style.backgroundImage = `url('${imageUrls.shell}')`;
                setTimeout(() => {
                    clickedShell.style.opacity = '0';
                    setTimeout(() => {
                        clickedShell.remove();
                        spawnPilgrimCrab();
                        spawnEighthShell();
                    }, 1000); 
                }, 4000);
            }, 12000); 
        }

        function handleEighthShellClick(event) {
            const clickedShell = event.currentTarget;
            clickedShell.style.backgroundImage = `url('${imageUrls.hermit}')`;
            subtitle.style.opacity = '1';
            subtitle.textContent = 'approach too fast with open claws';

            setTimeout(() => { subtitle.textContent = "they'll fight or flee."; }, 4000);
            setTimeout(() => { subtitle.textContent = 'warrior crabs fence, pince their arms to sever their claws.'; }, 8000);
            setTimeout(() => {
                subtitle.style.opacity = '0';
                clickedShell.style.backgroundImage = `url('${imageUrls.shell}')`;
                setTimeout(() => {
                    clickedShell.style.opacity = '0';
                    setTimeout(() => clickedShell.remove(), 1000);
                }, 4000);
            }, 12000);
        }

        function spawnShell(clickHandler) {
            const shellEl = document.createElement('div');
            shellEl.classList.add('shell');
            const shellWidth = 182;
            const shellHeight = 152;
            const x = Math.random() * (worldSize - shellWidth); 
            const y = Math.random() * (worldSize - shellHeight);
            shellEl.style.left = `${x}px`;
            shellEl.style.top = `${y}px`;
            world.appendChild(shellEl);
            shellEl.addEventListener('click', clickHandler, { once: true });
        }

        function spawnRandomShell() { spawnShell(handleShellClick); spawnPilgrimCrab(); }
        function spawnThirdShell() { spawnShell(handleThirdShellClick); }
        function spawnSeventhShell() { spawnShell(handleSeventhShellClick); }
        function spawnEighthShell() { spawnShell(handleEighthShellClick); }

        function spawnPilgrimCrab() {
            const newPilgrimCrab = document.createElement('div');
            newPilgrimCrab.className = 'crab'; 

            const body = document.createElement('div');
            body.className = 'crab-part crab-body';
            const rightArmEl = document.createElement('div');
            rightArmEl.className = 'crab-part arm right-arm';
            const rightClawElement = document.createElement('div');
            rightClawElement.className = 'crab-part right-claw';
            const leftArmEl = document.createElement('div');
            leftArmEl.className = 'crab-part arm left-arm';
            const leftClawElement = document.createElement('div');
            leftClawElement.className = 'crab-part left-claw';
            
            leftClawElement.style.backgroundImage = `url('${imageUrls.leftClosed}')`;
            rightClawElement.style.backgroundImage = `url('${imageUrls.rightClosed}')`;

            rightArmEl.appendChild(rightClawElement);
            leftArmEl.appendChild(leftClawElement);
            newPilgrimCrab.appendChild(body);
            newPilgrimCrab.appendChild(rightArmEl);
            newPilgrimCrab.appendChild(leftArmEl);
            
            world.appendChild(newPilgrimCrab);

            const pilgrimWidth = 281;
            const pilgrimHeight = 196;
            const x = Math.random() * (worldSize - pilgrimWidth);
            const y = Math.random() * (worldSize - pilgrimHeight);

            const pilgrimState = {
                x: x, y: y, angle: Math.random() * 360,
                width: pilgrimWidth, height: pilgrimHeight, speed: 1, 
                targetX: Math.random() * (worldSize - pilgrimWidth),
                targetY: Math.random() * (worldSize - pilgrimHeight),
                domElements: { rightArm: rightArmEl, rightClaw: rightClawElement, leftArm: leftArmEl, leftClaw: leftClawElement },
                swayTime: Math.random() * 2000, clawTime: Math.random() * 2000,
                clawsClosed: true,
                state: 'wandering', 
                leader: null, followDistance: 300,
                fleeTimer: 0, fleeFrom: null,
                hasLeftArm: true, hasRightArm: true,
                targetCrab: null, attackCooldown: 0,
                isAttacking: false,
                attackPhase: 'none', 
                attackTimer: 0,
                strafeDirection: 1,
                strafeTimer: 0,
                attackArm: null,
                targetLimb: null,
                initialAttackAngles: null,
                targetAttackAngles: null,
                heldClaw: null,
                scavengeTarget: null,
                rescueTarget: null
            };

            pilgrims.push({ domElement: newPilgrimCrab, state: pilgrimState });
        }

        function createSeaweed() {
            for (let i = 0; i < seaweedCount; i++) {
                const seaweedEl = document.createElement('div');
                seaweedEl.classList.add('seaweed');
                const x = Math.random() * (worldSize - 246); 
                const y = Math.random() * (worldSize - 430); 
                seaweedEl.style.left = `${x}px`;
                seaweedEl.style.top = `${y}px`;
                const duration = Math.random() * 5 + 4;
                const delay = Math.random() * 5;
                seaweedEl.style.animationDuration = `${duration}s`;
                seaweedEl.style.animationDelay = `-${delay}s`;
                world.appendChild(seaweedEl);
            }
        }
        
        function createCrab() {
            crab = document.createElement('div');
            crab.id = 'crab';
            crab.className = 'crab'; 

            const body = document.createElement('div');
            body.className = 'crab-part crab-body';
            rightArm = document.createElement('div');
            rightArm.className = 'crab-part arm right-arm';
            rightClawEl = document.createElement('div');
            rightClawEl.className = 'crab-part right-claw';
            leftArm = document.createElement('div');
            leftArm.className = 'crab-part arm left-arm';
            leftClawEl = document.createElement('div');
            leftClawEl.className = 'crab-part left-claw';

            rightArm.appendChild(rightClawEl);
            leftArm.appendChild(leftClawEl);
            crab.appendChild(body);
            crab.appendChild(rightArm);
            crab.appendChild(leftArm);
            
            crab.style.left = `${crabState.x - crabState.width / 2}px`;
            crab.style.top = `${crabState.y - crabState.height / 2}px`;

            world.appendChild(crab);
            crabState.domElements = { rightArm, rightClaw: rightClawEl, leftArm, leftClaw: leftClawEl, body: body };
        }
        
        const ARM_LENGTH = 82;
        const CLAW_WIDTH = 197;
        const CLAW_HEIGHT = 77;
        const CLAW_EFFECTIVE_LENGTH = Math.sqrt(CLAW_WIDTH * CLAW_WIDTH + CLAW_HEIGHT * CLAW_HEIGHT); 
        const RIGHT_CLAW_INTERNAL_ANGLE_RAD = Math.atan2(CLAW_HEIGHT, CLAW_WIDTH);
        const LEFT_CLAW_INTERNAL_ANGLE_RAD = Math.atan2(CLAW_HEIGHT, -CLAW_WIDTH);

        function solveIK(shoulderX, shoulderY, targetX, targetY, armLength, clawLength, isLeftHand) {
            const dx = targetX - shoulderX;
            const dy = targetY - shoulderY;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);

            const L1 = armLength; const L2 = clawLength;
            let armAngleRad, clawAngleRad;
            
            if (dist >= L1 + L2) {
                const angle = Math.atan2(dy, dx);
                armAngleRad = angle;
                clawAngleRad = angle;
            } else {
                const angle1 = Math.atan2(dy, dx);
                if (dist < Math.abs(L1 - L2)) {
                    armAngleRad = angle1;
                    clawAngleRad = angle1 + Math.PI;
                } else {
                    const denominator = 2 * dist * L1;
                    if (Math.abs(denominator) < 0.0001) { // Avoid division by zero when zoomed out
                        const angle = Math.atan2(dy, dx);
                        return { armAngleRad: angle, clawAngleRad: angle };
                    }

                    const acosArg = (distSq + L1 * L1 - L2 * L2) / denominator;
            
                    const acosArgClamped = Math.max(-1, Math.min(1, acosArg));

                    const angle2 = Math.acos(acosArgClamped);
                    if (isLeftHand) armAngleRad = angle1 - angle2;
                    else armAngleRad = angle1 + angle2;
                    const wristX = shoulderX + L1 * Math.cos(armAngleRad);
                    const wristY = shoulderY + L1 * Math.sin(armAngleRad);
                    clawAngleRad = Math.atan2(targetY - wristY, targetX - wristX);
                }
            }
            return { armAngleRad, clawAngleRad };
        }

        function updatePilgrimClaws(pilgrim) {
            if (pilgrim.state.hasLeftArm && pilgrim.state.domElements.leftClaw) {
                pilgrim.state.domElements.leftClaw.style.backgroundImage = `url('${pilgrim.state.clawsClosed ? imageUrls.leftClosed : imageUrls.leftOpen}')`;
            }
             if (pilgrim.state.hasRightArm && pilgrim.state.domElements.rightClaw) {
                pilgrim.state.domElements.rightClaw.style.backgroundImage = `url('${pilgrim.state.clawsClosed ? imageUrls.rightClosed : imageUrls.rightOpen}')`;
            }

            pilgrim.state.clawTime += 2; 
            const baseClawRotation = Math.sin(pilgrim.state.clawTime * 0.002) * 20; 
            const armSwayAngle = Math.sin(pilgrim.state.clawTime * 0.002 + Math.PI / 4) * 8; 

            if (pilgrim.state.hasLeftArm && pilgrim.state.domElements.leftArm) {
                pilgrim.state.domElements.leftClaw.style.transform = `rotate(${baseClawRotation}deg)`;
                pilgrim.state.domElements.leftArm.style.transform = `rotate(${armSwayAngle}deg)`;
            }
            if (pilgrim.state.hasRightArm && pilgrim.state.domElements.rightArm) {
                pilgrim.state.domElements.rightClaw.style.transform = `rotate(${-baseClawRotation}deg)`;
                pilgrim.state.domElements.rightArm.style.transform = `rotate(${-armSwayAngle}deg)`;
            }
        }
        
        function areCrabsColliding(crab1, crab2) {
            if (!crab1 || !crab2) return false;
            const dx = crab1.x - crab2.x;
            const dy = crab1.y - crab2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const r1 = (crab1.width + crab1.height) / 4;
            const r2 = (crab2.width + crab2.height) / 4;
            return distance < (r1 + r2);
        }
        
        function getAbsoluteBoundingBox(element) {
            const rect = element.getBoundingClientRect();
            const screenCenterX = window.innerWidth / 2;
            const screenCenterY = window.innerHeight / 2;
            const worldX = (rect.left - screenCenterX) / camera.zoom + crabState.x;
            const worldY = (rect.top - screenCenterY) / camera.zoom + crabState.y;
            const worldWidth = rect.width / camera.zoom;
            const worldHeight = rect.height / camera.zoom;
            return { x: worldX, y: worldY, width: worldWidth, height: worldHeight };
        }

        function getSocketBox(crabObjState, limbSide) {
            const scale = crabObjState.scale || 1.0;
            const armPivotOffsetY = 170 - crabObjState.height / 2;
            const pivotOffsetX = limbSide === 'left' 
                ? (200 + 57 / 2) - crabObjState.width / 2 
                : (25 + 57 / 2) - crabObjState.width / 2;

            const crabAngleRad = crabObjState.angle * (Math.PI / 180);
            const cosCrab = Math.cos(crabAngleRad);
            const sinCrab = Math.sin(crabAngleRad);

            const socketWorldX = crabObjState.x + ((pivotOffsetX * cosCrab - armPivotOffsetY * sinCrab) * scale);
            const socketWorldY = crabObjState.y + ((pivotOffsetX * sinCrab + armPivotOffsetY * cosCrab) * scale);
            
            const socketSize = 20;
            return {
                x: socketWorldX - socketSize / 2,
                y: socketWorldY - socketSize / 2,
                width: socketSize,
                height: socketSize
            };
        }

        function checkAABBCollision(box1, box2) {
            return (
                box1.x < box2.x + box2.width &&
                box1.x + box1.width > box2.x &&
                box1.y < box2.y + box2.height &&
                box1.y + box1.height > box2.y
            );
        }

        function findNearestSeveredClaw(x, y, radius) {
            const severedClaws = document.querySelectorAll('.severed-claw');
            let closestClaw = null;
            let minDistanceSq = radius * radius;

            for (const claw of severedClaws) {
                // Skip if it's being held by the player
                if (crabState.heldClaw && crabState.heldClaw.element === claw) continue;
                
                const clawX = parseFloat(claw.style.left);
                const clawY = parseFloat(claw.style.top);
                const dx = clawX - x;
                const dy = clawY - y;
                const distanceSq = dx * dx + dy * dy;
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestClaw = claw;
                }
            }
            return closestClaw;
        }

        function checkProximityAndFriendship(pilgrim) {
            const isLight = lightOverlay.style.opacity < 0.5;
            if (!isLight) return; 
            if (pilgrim.state.state !== 'wandering') return;

            let potentialFriend = null;
            let minDistance = 600;

            const dxPlayer = crabState.x - pilgrim.state.x;
            const dyPlayer = crabState.y - pilgrim.state.y;
            const distancePlayer = Math.sqrt(dxPlayer * dxPlayer + dyPlayer * dyPlayer);

            if (distancePlayer < minDistance) {
                if ((leftClawClosed && rightClawClosed) || crabState.isDancing) {
                    potentialFriend = { state: crabState, clawsClosed: true, id: 'player' };
                    minDistance = distancePlayer;
                }
            }

            for (const otherPilgrim of pilgrims) {
                if (otherPilgrim.domElement === pilgrim.domElement) continue; 
                if (otherPilgrim.state.state === 'courting' || otherPilgrim.state.state === 'warrior') continue;
                if (otherPilgrim.state.leader === pilgrim.state) continue;

                const dx = otherPilgrim.state.x - pilgrim.state.x;
                const dy = otherPilgrim.state.y - pilgrim.state.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < minDistance) {
                    if (otherPilgrim.state.clawsClosed) {
                        potentialFriend = { state: otherPilgrim.state, clawsClosed: true, id: otherPilgrim.domElement };
                        minDistance = distance;
                    }
                }
            }

            if (potentialFriend) {
                pilgrim.state.state = 'courting';
                pilgrim.state.leader = potentialFriend.state;
                pilgrim.state.clawsClosed = true; 
            }
        }

        function detachLimb(crabObject, limb) {
            const state = crabObject.state || crabObject;
            const armEl = state.domElements[limb + 'Arm'];
            const clawEl = state.domElements[limb + 'Claw'];

            if (!armEl || !clawEl) return;

            const clawRect = clawEl.getBoundingClientRect();
            const screenCenterX = window.innerWidth / 2;
            const screenCenterY = window.innerHeight / 2;
            const finalX = (clawRect.left - screenCenterX) / camera.zoom + crabState.x;
            const finalY = (clawRect.top - screenCenterY) / camera.zoom + crabState.y;
            
            const parentTransform = (state.domElements[limb + 'Arm'] || crab).style.transform;
            const clawTransform = clawEl.style.transform;
            const parentAngleMatch = parentTransform.match(/rotate\(([^deg]+)deg\)/);
            const clawAngleMatch = clawTransform.match(/rotate\(([^deg]+)deg\)/);
            const parentAngle = parentAngleMatch ? parseFloat(parentAngleMatch[1]) : 0;
            const clawAngle = clawAngleMatch ? parseFloat(clawAngleMatch[1]) : 0;
            const finalAngle = state.angle + parentAngle + clawAngle;

            world.appendChild(clawEl);
            clawEl.style.left = `${finalX}px`;
            clawEl.style.top = `${finalY}px`;
            clawEl.style.transform = `rotate(${finalAngle}deg)`;
            clawEl.classList.add('severed-claw');
            clawEl.dataset.clawType = limb;
            clawEl.style.zIndex = 5;

            armEl.style.display = 'none';
            state['has' + (limb.charAt(0).toUpperCase() + limb.slice(1)) + 'Arm'] = false;
        }

        function checkForClawPickup(playerClawEl, holdingHand) {
            if (crabState.heldClaw) return;

            const playerClawBox = getAbsoluteBoundingBox(playerClawEl);
            const severedClaws = document.querySelectorAll('.severed-claw');

            for (const severedClaw of severedClaws) {
                const severedClawBox = getAbsoluteBoundingBox(severedClaw);
                if (checkAABBCollision(playerClawBox, severedClawBox)) {
                    crabState.heldClaw = {
                        element: severedClaw,
                        holdingHand: holdingHand,
                        type: severedClaw.dataset.clawType
                    };
                    playerClawEl.appendChild(severedClaw);
                    severedClaw.style.left = '120px';
                    severedClaw.style.top = '10px';
                    severedClaw.style.transform = 'rotate(15deg)';
                    severedClaw.classList.remove('severed-claw');
                    return;
                }
            }
        }

        function dropHeldClaw() {
            if (!crabState.heldClaw) return;

            const clawToDrop = crabState.heldClaw.element;
            
            const clawRect = clawToDrop.getBoundingClientRect();
            const screenCenterX = window.innerWidth / 2;
            const screenCenterY = window.innerHeight / 2;
            const finalX = (clawRect.left - screenCenterX) / camera.zoom + crabState.x;
            const finalY = (clawRect.top - screenCenterY) / camera.zoom + crabState.y;

            const holdingHand = crabState.heldClaw.holdingHand;
            const armAngle = holdingHand === 'left' ? crabState.leftArmAngle : crabState.rightArmAngle;
            const clawAngle = holdingHand === 'left' ? crabState.leftClawAngle : crabState.rightClawAngle;
            const finalAngle = armAngle + clawAngle + 15;

            world.appendChild(clawToDrop);
            clawToDrop.style.left = `${finalX}px`;
            clawToDrop.style.top = `${finalY}px`;
            clawToDrop.style.transform = `rotate(${finalAngle}deg)`;
            clawToDrop.classList.add('severed-claw');

            crabState.heldClaw = null;
            crabState.eatTimer = 0;
        }
        
        function regenerateLimb(targetState, newClawElement, specificLimb = null) {
            const tryRegen = (limb) => {
                const hasLimbProp = 'has' + (limb.charAt(0).toUpperCase() + limb.slice(1)) + 'Arm';
                if (!targetState[hasLimbProp]) {
                    const armEl = targetState.domElements[limb + 'Arm'];
                    
                    // Remove the crab's old, original claw element if it exists
                    if (targetState.domElements[limb + 'Claw']) {
                        targetState.domElements[limb + 'Claw'].remove();
                    }

                    // The new claw element is now the official claw for this limb
                    targetState.domElements[limb + 'Claw'] = newClawElement;
                    
                    // If it's the player, update the global reference too
                    if (targetState === crabState) {
                        if (limb === 'left') leftClawEl = newClawElement;
                        if (limb === 'right') rightClawEl = newClawElement;
                    }

                    // Attach new claw to the arm, resetting its properties
                    armEl.appendChild(newClawElement);
                    newClawElement.className = 'crab-part ' + limb + '-claw'; // Critical for transform-origin
                    newClawElement.style.left = '';
                    newClawElement.style.top = '';
                    newClawElement.style.transform = '';
                    newClawElement.style.zIndex = '';
                    
                    // Restore "open" image based on its new identity
                    const isOpenImage = imageUrls[limb + 'Open'];
                    newClawElement.style.backgroundImage = `url('${isOpenImage}')`;
                    
                    // Make the arm visible
                    armEl.style.display = 'block';
                    
                    // Update state flag
                    targetState[hasLimbProp] = true;

                    // Update the crab's state variables to match the "open" state
                    if (targetState === crabState) {
                        if (limb === 'left') leftClawClosed = false;
                        if (limb === 'right') rightClawClosed = false;
                        updateClawImages();
                    } else { 
                        targetState.clawsClosed = false;
                    }
                    
                    return true;
                }
                return false;
            };

            if (specificLimb) {
                return tryRegen(specificLimb);
            } else {
                if (tryRegen('left')) return true;
                if (tryRegen('right')) return true;
                return false;
            }
        }
        
        function eatClaw(clawElement) {
            if (!crabState.hasLeftArm || !crabState.hasRightArm) {
                 regenerateLimb(crabState, clawElement);
            } else {
                 growCrab();
                 clawElement.remove(); // Claw is consumed for growth
            }
        }

        function growCrab() {
            crabState.scale *= 1.01;
        }

        function checkForPlayerAttack(clawElement) {
             const clawBox = getAbsoluteBoundingBox(clawElement);
             for(const pilgrim of pilgrims) {
                 if (!pilgrim.state.hasLeftArm && !pilgrim.state.hasRightArm) continue;

                 if(pilgrim.state.hasLeftArm) {
                     const armBox = getAbsoluteBoundingBox(pilgrim.state.domElements.leftArm);
                     if (checkAABBCollision(clawBox, armBox)) {
                         detachLimb(pilgrim, 'left');
                         return;
                     }
                 }
                 if(pilgrim.state.hasRightArm) {
                     const armBox = getAbsoluteBoundingBox(pilgrim.state.domElements.rightArm);
                     if (checkAABBCollision(clawBox, armBox)) {
                         detachLimb(pilgrim, 'right');
                         return;
                     }
                 }
             }
        }
        
        function gameLoop(timestamp) {
            if (!crab) { requestAnimationFrame(gameLoop); return; }

            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            const isLight = lightOverlay.style.opacity < 0.5;
            lightCycleTimer = (lightCycleTimer + deltaTime) % 40000;
            let opacity = 1;
            if (lightCycleTimer < 15000) opacity = 1;
            else if (lightCycleTimer < 20000) opacity = 1 - (lightCycleTimer - 15000) / 5000;
            else if (lightCycleTimer < 25000) opacity = 0;
            else opacity = (lightCycleTimer - 25000) / 15000;
            lightOverlay.style.opacity = opacity;

            const crabScreenCenterX = window.innerWidth / 2;
            const crabScreenCenterY = window.innerHeight / 2;

            const dx = mouse.x - crabScreenCenterX;
            const dy = mouse.y - crabScreenCenterY;
            const screenDistance = Math.sqrt(dx * dx + dy * dy);
            
            const stopRadius = 340;
            const worldDistance = screenDistance / camera.zoom;
            let playerSpeed = 0;

            if ((crabState.hasLeftArm || crabState.hasRightArm) && worldDistance > stopRadius) {
                const angleRad = Math.atan2(dy, dx);
                crabState.angle = angleRad * (180 / Math.PI) - 90; 
                const speedFactor = 0.03;
                const maxSpeed = 8;
                playerSpeed = Math.min(maxSpeed, (worldDistance - stopRadius) * speedFactor); 
                crabState.x += Math.cos(angleRad) * playerSpeed;
                crabState.y += Math.sin(angleRad) * playerSpeed;
            }

            crabState.x = Math.max(crabState.width / 2, Math.min(worldSize - crabState.width / 2, crabState.x));
            crabState.y = Math.max(crabState.height / 2, Math.min(worldSize - crabState.height / 2, crabState.y));
            
            crab.style.left = `${crabState.x - crabState.width / 2}px`;
            crab.style.top = `${crabState.y - crabState.height / 2}px`;
            crab.style.transform = `rotate(${crabState.angle}deg) scale(${crabState.scale})`;
            
            world.style.transformOrigin = `${crabState.x}px ${crabState.y}px`;
            const cameraX = -crabState.x + window.innerWidth / 2;
            const cameraY = -crabState.y + window.innerHeight / 2;
            world.style.transform = `translate3d(${cameraX}px, ${cameraY}px, 0) scale(${camera.zoom})`;
            
            if (crabState.heldClaw) {
                const heldClawBox = getAbsoluteBoundingBox(crabState.heldClaw.element);
                const playerBodyBox = getAbsoluteBoundingBox(crabState.domElements.body);

                let repaired = false;
                if (!crabState.hasLeftArm) {
                    const leftSocketBox = getSocketBox(crabState, 'left');
                    if (checkAABBCollision(heldClawBox, leftSocketBox)) {
                        regenerateLimb(crabState, crabState.heldClaw.element, 'left');
                        crabState.heldClaw = null;
                        repaired = true;
                    }
                }
                if (!repaired && crabState.heldClaw && !crabState.hasRightArm) {
                    const rightSocketBox = getSocketBox(crabState, 'right');
                    if (checkAABBCollision(heldClawBox, rightSocketBox)) {
                        regenerateLimb(crabState, crabState.heldClaw.element, 'right');
                        crabState.heldClaw = null;
                        repaired = true;
                    }
                }
                if (!repaired && crabState.heldClaw) {
                     for (const pilgrim of pilgrims) {
                        const state = pilgrim.state;
                         if (!state.hasLeftArm || !state.hasRightArm) {
                            if (!state.hasLeftArm) {
                                const pilgrimSocketBox = getSocketBox(state, 'left');
                                if (checkAABBCollision(heldClawBox, pilgrimSocketBox)) {
                                    regenerateLimb(state, crabState.heldClaw.element, 'left');
                                    crabState.heldClaw = null;
                                    if (state.leader !== crabState) { state.leader = crabState; state.state = 'following'; }
                                    repaired = true;
                                    break;
                                }
                            }
                            if (!repaired && crabState.heldClaw && !state.hasRightArm) {
                                const pilgrimSocketBox = getSocketBox(state, 'right');
                                if (checkAABBCollision(heldClawBox, pilgrimSocketBox)) {
                                    regenerateLimb(state, crabState.heldClaw.element, 'right');
                                    crabState.heldClaw = null;
                                    if (state.leader !== crabState) { state.leader = crabState; state.state = 'following'; }
                                    repaired = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                if (!repaired && crabState.heldClaw && checkAABBCollision(heldClawBox, playerBodyBox)) {
                    crabState.eatTimer += deltaTime;
                    if (crabState.eatimer >= 3000) {
                        eatClaw(crabState.heldClaw.element);
                        crabState.heldClaw = null;
                        crabState.eatTimer = 0;
                    }
                } else {
                    crabState.eatTimer = 0;
                }
            } else if (crabState.eatTimer > 0) {
                crabState.eatTimer = 0;
            }

            crabState.isDancing = mouseState.leftDown && mouseState.rightDown;

            const armPivotOffsetY = 170 - crabState.height / 2;
            const rightArmPivotOffsetX = (25 + 57 / 2) - crabState.width / 2;
            const leftArmPivotOffsetX = (200 + 57 / 2) - crabState.width / 2; 
            
            const crabAngleRad = crabState.angle * (Math.PI / 180);
            const cosCrab = Math.cos(crabAngleRad);
            const sinCrab = Math.sin(crabAngleRad);

            const rightShoulderX = crabScreenCenterX + ((rightArmPivotOffsetX * cosCrab - armPivotOffsetY * sinCrab) * crabState.scale) * camera.zoom;
            const rightShoulderY = crabScreenCenterY + ((rightArmPivotOffsetX * sinCrab + armPivotOffsetY * cosCrab) * crabState.scale) * camera.zoom;
            const leftShoulderX = crabScreenCenterX + ((leftArmPivotOffsetX * cosCrab - armPivotOffsetY * sinCrab) * crabState.scale) * camera.zoom;
            const leftShoulderY = crabScreenCenterY + ((leftArmPivotOffsetX * sinCrab + armPivotOffsetY * cosCrab) * crabState.scale) * camera.zoom;
            
            const scaledArmLength = (ARM_LENGTH * crabState.scale) * camera.zoom;
            const scaledClawLength = (CLAW_EFFECTIVE_LENGTH * crabState.scale) * camera.zoom;
            
            let finalRightArmAngleDeg, finalRightClawAngleDeg, finalLeftArmAngleDeg, finalLeftClawAngleDeg;
            let currentControl = activeControl;
            if (crabState.isDancing) currentControl = 'both';

            if (currentControl === 'right' && crabState.hasRightArm) {
                const { armAngleRad, clawAngleRad } = solveIK(rightShoulderX, rightShoulderY, mouse.x, mouse.y, scaledArmLength, scaledClawLength, false);
                const armWorldAngleDeg = armAngleRad * (180 / Math.PI) - 90;
                const clawWorldAngleDeg = (clawAngleRad - RIGHT_CLAW_INTERNAL_ANGLE_RAD) * (180 / Math.PI);
                finalRightArmAngleDeg = armWorldAngleDeg;
                finalRightClawAngleDeg = clawWorldAngleDeg - armWorldAngleDeg;
                finalLeftArmAngleDeg = crabState.leftArmAngle;
                finalLeftClawAngleDeg = crabState.leftClawAngle;
            } else if (currentControl === 'left' && crabState.hasLeftArm) { 
                const { armAngleRad, clawAngleRad } = solveIK(leftShoulderX, leftShoulderY, mouse.x, mouse.y, scaledArmLength, scaledClawLength, true);
                const armWorldAngleDeg = armAngleRad * (180 / Math.PI) - 90;
                const clawWorldAngleDeg = (clawAngleRad - LEFT_CLAW_INTERNAL_ANGLE_RAD) * (180 / Math.PI);
                finalLeftArmAngleDeg = armWorldAngleDeg;
                finalLeftClawAngleDeg = clawWorldAngleDeg - armWorldAngleDeg;
                finalRightArmAngleDeg = crabState.rightArmAngle;
                finalRightClawAngleDeg = crabState.rightClawAngle;
            } else if (currentControl === 'both') {
                const clawSeparation = 150; 
                const mouseAngleRad = Math.atan2(mouse.y - crabScreenCenterY, mouse.x - crabScreenCenterX);
                const offsetX = (clawSeparation / 2) * Math.cos(mouseAngleRad + Math.PI / 2);
                const offsetY = (clawSeparation / 2) * Math.sin(mouseAngleRad + Math.PI / 2);

                if (crabState.hasLeftArm) {
                    const { armAngleRad, clawAngleRad } = solveIK(leftShoulderX, leftShoulderY, mouse.x - offsetX, mouse.y - offsetY, scaledArmLength, scaledClawLength, true);
                    finalLeftArmAngleDeg = armAngleRad * (180 / Math.PI) - 90;
                    finalLeftClawAngleDeg = (clawAngleRad - LEFT_CLAW_INTERNAL_ANGLE_RAD) * (180 / Math.PI) - finalLeftArmAngleDeg;
                }
                if (crabState.hasRightArm) {
                    const { armAngleRad, clawAngleRad } = solveIK(rightShoulderX, rightShoulderY, mouse.x + offsetX, mouse.y + offsetY, scaledArmLength, scaledClawLength, false);
                    finalRightArmAngleDeg = armAngleRad * (180 / Math.PI) - 90;
                    finalRightClawAngleDeg = (clawAngleRad - RIGHT_CLAW_INTERNAL_ANGLE_RAD) * (180 / Math.PI) - finalRightArmAngleDeg;
                }
            } else { 
                finalRightArmAngleDeg = crabState.rightArmAngle;
                finalRightClawAngleDeg = crabState.rightClawAngle;
                finalLeftArmAngleDeg = crabState.leftArmAngle;
                finalLeftClawAngleDeg = crabState.leftClawAngle;
            }
            
            crabState.rightArmAngle = finalRightArmAngleDeg;
            crabState.rightClawAngle = finalRightClawAngleDeg;
            crabState.leftArmAngle = finalLeftArmAngleDeg;
            crabState.leftClawAngle = finalLeftClawAngleDeg;

            if(crabState.hasRightArm) {
                rightArm.style.transform = `rotate(${crabState.rightArmAngle - crabState.angle}deg)`;
                rightClawEl.style.transform = `rotate(${crabState.rightClawAngle}deg)`;
            }
            if(crabState.hasLeftArm) {
                leftArm.style.transform = `rotate(${crabState.leftArmAngle - crabState.angle}deg)`;
                leftClawEl.style.transform = `rotate(${crabState.leftClawAngle}deg)`;
            }

            for (const pilgrim of pilgrims) {
                const state = pilgrim.state;
                const element = pilgrim.domElement;
                const canMove = state.hasLeftArm || state.hasRightArm;

                // --- Transition Logic ---
                const isPlayerDisabled = !crabState.hasLeftArm && !crabState.hasRightArm;
                if (state.state === 'wandering' && (state.hasLeftArm !== state.hasRightArm) && !state.heldClaw) { // A one-armed crab will scavenge
                    const nearbyClaw = findNearestSeveredClaw(state.x, state.y, 500);
                    if (nearbyClaw) {
                        state.state = 'scavenging';
                        state.scavengeTarget = nearbyClaw;
                    }
                } else if (state.state === 'following' && state.leader === crabState && isPlayerDisabled && !state.heldClaw) {
                    const nearbyClaw = findNearestSeveredClaw(state.x, state.y, 1000);
                    if (nearbyClaw) {
                        state.state = 'rescuing';
                        state.scavengeTarget = nearbyClaw;
                        state.rescueTarget = crabState;
                    }
                } else if (state.state !== 'warrior' && state.state !== 'fleeing' && state.state !== 'rescuing' && state.state !== 'scavenging') {
                    const distToPlayer = Math.sqrt(Math.pow(state.x - crabState.x, 2) + Math.pow(state.y - crabState.y, 2));
                    const AGGRO_RANGE = 400;
                    const AGGRESSION_SPEED_THRESHOLD = 5;

                    if (distToPlayer < AGGRO_RANGE && playerSpeed > AGGRESSION_SPEED_THRESHOLD && (!leftClawClosed || !rightClawClosed)) {
                        state.leader = null;
                        state.state = isLight ? 'warrior' : 'fleeing';
                        state.fleeFrom = crabState;
                        state.fleeTimer = 200; 
                    } else {
                        for (const other of pilgrims) {
                            if (other === pilgrim) continue;
                            if (other.state.state === 'fleeing' || other.state.state === 'warrior') {
                                const distToOther = Math.sqrt(Math.pow(state.x - other.state.x, 2) + Math.pow(state.y - other.state.y, 2));
                                if (distToOther < AGGRO_RANGE) {
                                     state.leader = null;
                                     state.state = isLight && other.state.state === 'warrior' ? 'warrior' : 'fleeing';
                                     state.targetCrab = isLight ? other.state : null;
                                     state.fleeFrom = other.state;
                                     state.fleeTimer = 100; 
                                     break; 
                                }
                            }
                        }
                    }
                }
                
                // --- State Machine ---
                switch (state.state) {
                    case 'wandering':
                        if (canMove) {
                            checkProximityAndFriendship(pilgrim);
                            const dxToTarget = state.targetX - state.x;
                            const dyToTarget = state.targetY - state.y;
                            if (Math.sqrt(dxToTarget*dxToTarget + dyToTarget*dyToTarget) < 100) { 
                                state.targetX = Math.random() * (worldSize - state.width);
                                state.targetY = Math.random() * (worldSize - state.height);
                            }
                            const targetAngle = Math.atan2(dyToTarget, dxToTarget) * (180 / Math.PI) - 90;
                            let angleDiff = targetAngle - state.angle;
                            while (angleDiff < -180) angleDiff += 360;
                            while (angleDiff > 180) angleDiff -= 360;
                            state.angle += Math.max(-0.5, Math.min(0.5, angleDiff));
                            const moveAngleRad = (state.angle + 90) * (Math.PI / 180);
                            state.x += Math.cos(moveAngleRad) * state.speed;
                            state.y += Math.sin(moveAngleRad) * state.speed;
                        }
                        break;
                    case 'scavenging':
                         if (!state.scavengeTarget || state.scavengeTarget.parentElement !== world) {
                            state.state = 'wandering'; state.scavengeTarget = null; break;
                         }
                         const targetX = parseFloat(state.scavengeTarget.style.left);
                         const targetY = parseFloat(state.scavengeTarget.style.top);
                         const dxToClaw = targetX - state.x;
                         const dyToClaw = targetY - state.y;
                         const distToClaw = Math.sqrt(dxToClaw * dxToClaw + dyToClaw * dyToClaw);
                         if (distToClaw < 50) {
                             regenerateLimb(state, state.scavengeTarget);
                             state.scavengeTarget = null;
                             state.state = 'wandering';
                         } else if (canMove) {
                             const targetAngle = Math.atan2(dyToClaw, dxToClaw) * (180 / Math.PI) - 90;
                             state.angle = targetAngle;
                             const moveAngleRad = (state.angle + 90) * (Math.PI / 180);
                             state.x += Math.cos(moveAngleRad) * state.speed * 2; // Move faster
                             state.y += Math.sin(moveAngleRad) * state.speed * 2;
                         }
                         break;
                    case 'rescuing':
                         // Phase 1: Get claw
                         if (!state.heldClaw) {
                            if (!state.scavengeTarget || state.scavengeTarget.parentElement !== world) {
                                state.state = 'following'; state.scavengeTarget = null; break;
                            }
                             const cX = parseFloat(state.scavengeTarget.style.left);
                             const cY = parseFloat(state.scavengeTarget.style.top);
                             const dX = cX - state.x;
                             const dY = cY - state.y;
                             if (Math.sqrt(dX * dX + dY * dY) < 50) {
                                state.heldClaw = { element: state.scavengeTarget };
                                state.scavengeTarget.style.display = 'none'; // "hide" it
                                state.scavengeTarget = null;
                             } else if (canMove) {
                                state.angle = Math.atan2(dY, dX) * (180 / Math.PI) - 90;
                                const moveAngleRad = (state.angle + 90) * (Math.PI / 180);
                                state.x += Math.cos(moveAngleRad) * state.speed * 2;
                                state.y += Math.sin(moveAngleRad) * state.speed * 2;
                             }
                         }
                         // Phase 2: Bring to player
                         else {
                            if (!state.rescueTarget || (state.rescueTarget.hasLeftArm && state.rescueTarget.hasRightArm)) {
                                // Player is already healed, drop claw and go back
                                if(state.heldClaw) state.heldClaw.element.remove();
                                state.heldClaw = null;
                                state.state = 'following';
                                break;
                            }
                            const dxToPlayer = state.rescueTarget.x - state.x;
                            const dyToPlayer = state.rescueTarget.y - state.y;
                            if (Math.sqrt(dxToPlayer * dxToPlayer + dyToPlayer * dyToPlayer) < 150) {
                                regenerateLimb(state.rescueTarget, state.heldClaw.element);
                                state.heldClaw = null;
                                state.state = 'following';
                            } else if (canMove) {
                                state.angle = Math.atan2(dyToPlayer, dxToPlayer) * (180 / Math.PI) - 90;
                                const moveAngleRad = (state.angle + 90) * (Math.PI / 180);
                                state.x += Math.cos(moveAngleRad) * state.speed * 1.5;
                                state.y += Math.sin(moveAngleRad) * state.speed * 1.5;
                            }
                         }
                         break;
                    case 'courting':
                        if (!state.leader) { state.state = 'wandering'; break; }
                        const dxToLeader = state.leader.x - state.x;
                        const dyToLeader = state.leader.y - state.y;
                        if (areCrabsColliding(state, state.leader)) {
                            state.state = 'following';
                            state.clawsClosed = true;
                        } else if (canMove) {
                            const targetAngle = Math.atan2(dyToLeader, dxToLeader) * (180 / Math.PI) - 90;
                            let angleDiff = targetAngle - state.angle;
                            while (angleDiff < -180) angleDiff += 360;
                            while (angleDiff > 180) angleDiff -= 360;
                            state.angle += Math.max(-0.5, Math.min(0.5, angleDiff));
                            const moveAngleRad = (state.angle + 90) * (Math.PI / 180);
                            state.x += Math.cos(moveAngleRad) * 1; 
                            state.y += Math.sin(moveAngleRad) * 1;
                        }
                        break;
                    case 'following':
                        if (!state.leader) { state.state = 'wandering'; break; }
                        if (canMove) {
                            const leaderAngleRad = (state.leader.angle + 90) * Math.PI / 180;
                            const targetX = state.leader.x - state.followDistance * Math.cos(leaderAngleRad);
                            const targetY = state.leader.y - state.followDistance * Math.sin(leaderAngleRad);
                            const dxToFollowTarget = targetX - state.x;
                            const dyToFollowTarget = targetY - state.y;
                            if (Math.sqrt(dxToFollowTarget*dxToFollowTarget + dyToFollowTarget*dyToFollowTarget) > 100) { 
                                const followAngle = Math.atan2(dyToFollowTarget, dxToFollowTarget) * (180 / Math.PI) - 90;
                                let angleDiff = followAngle - state.angle;
                                while (angleDiff < -180) angleDiff += 360;
                                while (angleDiff > 180) angleDiff -= 360;
                                state.angle += Math.max(-1, Math.min(1, angleDiff));
                                const moveAngleRad = (state.angle + 90) * (Math.PI / 180);
                                state.x += Math.cos(moveAngleRad) * state.speed;
                                state.y += Math.sin(moveAngleRad) * state.speed;
                            }
                        }
                        break;
                    case 'warrior':
                        const BOXING_RANGE_MAX = 300;
                        const BOXING_RANGE_MIN = 200;
                        const STRAFE_SPEED = 1;

                        if (!state.targetCrab || (!state.targetCrab.hasLeftArm && !state.targetCrab.hasRightArm)) {
                            state.targetCrab = null; 
                            let closestDist = 500;
                            let potentialTarget = null;
                            const allTargets = [crabState, ...pilgrims.map(p => p.state)];
                            for(const other of allTargets) {
                                if(other === state || (other.leader && other.leader === state)) continue; 
                                if(!other.hasLeftArm && !other.hasRightArm) continue; 
                                const dist = Math.sqrt(Math.pow(state.x - other.x, 2) + Math.pow(state.y - other.y, 2));
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    potentialTarget = other;
                                }
                            }
                            state.targetCrab = potentialTarget;
                             if (!state.targetCrab) { state.state = 'wandering'; state.isAttacking = false; break; }
                        }
                        
                        if (state.targetCrab && canMove) {
                            const dxToTarget = state.targetCrab.x - state.x;
                            const dyToTarget = state.targetCrab.y - state.y;
                            const dist = Math.sqrt(dxToTarget*dxToTarget + dyToTarget*dyToTarget);
                            state.angle = Math.atan2(dyToTarget, dxToTarget) * (180 / Math.PI) - 90;
                            const moveAngleRad = (state.angle + 90) * (Math.PI / 180);
                            if (dist > BOXING_RANGE_MAX) {
                                state.x += Math.cos(moveAngleRad) * state.speed;
                                state.y += Math.sin(moveAngleRad) * state.speed;
                            } else if (dist < BOXING_RANGE_MIN) {
                                state.x -= Math.cos(moveAngleRad) * state.speed;
                                state.y -= Math.sin(moveAngleRad) * state.speed;
                            } else {
                                state.strafeTimer -= deltaTime;
                                if (state.strafeTimer <= 0) {
                                    state.strafeDirection *= -1;
                                    state.strafeTimer = Math.random() * 1000 + 500;
                                }
                                const strafeAngleRad = moveAngleRad + (Math.PI / 2) * state.strafeDirection;
                                state.x += Math.cos(strafeAngleRad) * STRAFE_SPEED;
                                state.y += Math.sin(strafeAngleRad) * STRAFE_SPEED;
                            }
                            state.attackCooldown -= deltaTime;
                            if (state.attackCooldown <= 0 && !state.isAttacking) {
                                state.isAttacking = true;
                                state.attackPhase = 'windup';
                                state.attackTimer = 200;
                                const attackWithRight = state.hasRightArm && (Math.random() > 0.5 || !state.hasLeftArm);
                                state.attackArm = attackWithRight ? 'right' : 'left';
                                const targetRight = state.targetCrab.hasRightArm && (Math.random() > 0.5 || !state.targetCrab.hasLeftArm);
                                state.targetLimb = targetRight ? 'right' : 'left';
                                const baseArmAngle = state.attackArm === 'left' ? 45 : -45;
                                state.initialAttackAngles = { arm: baseArmAngle, claw: 0 };
                                state.targetAttackAngles = { arm: baseArmAngle * 0.5, claw: 0 };
                                state.attackCooldown = 2500 + Math.random() * 1000;
                            }
                        } else if (!canMove) {
                             state.state = 'wandering';
                        }
                        break;
                    case 'fleeing':
                        if (state.fleeTimer <= 0 || !state.fleeFrom) {
                            state.state = 'wandering';
                            break;
                        }
                        if(canMove) {
                            state.fleeTimer--;
                            const dxAway = state.x - state.fleeFrom.x;
                            const dyAway = state.y - state.fleeFrom.y;
                            state.angle = Math.atan2(dyAway, dxAway) * (180 / Math.PI) - 90;
                            const fleeMoveAngleRad = (state.angle + 90) * (Math.PI / 180);
                            state.x += Math.cos(fleeMoveAngleRad) * 3;
                            state.y += Math.sin(fleeMoveAngleRad) * 3;
                        }
                        break;
                }
                
                const AVOIDANCE_FORCE = 0.5; 
                let avoidanceX = 0;
                let avoidanceY = 0;
                for (const other of pilgrims) {
                    if (pilgrim === other) continue; 
                    const dx = state.x - other.state.x;
                    const dy = state.y - other.state.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                     let requiredPersonalSpace = 100;
                    if (distance < requiredPersonalSpace && distance > 0) {
                        const pushFactor = (requiredPersonalSpace - distance) / requiredPersonalSpace;
                        avoidanceX += (dx / distance) * pushFactor;
                        avoidanceY += (dy / distance) * pushFactor;
                    }
                }
                const dxPlayerPush = state.x - crabState.x;
                const dyPlayerPush = state.y - crabState.y;
                const distPlayer = Math.sqrt(dxPlayerPush * dxPlayerPush + dyPlayerPush * dyPlayerPush);

                if (distPlayer < 100 && distPlayer > 0) {
                    const pushFactor = (100 - distPlayer) / 100;
                    avoidanceX += (dxPlayerPush / distPlayer) * pushFactor;
                    avoidanceY += (dyPlayerPush / distPlayer) * pushFactor;
                }
                if(canMove){
                    state.x += avoidanceX * AVOIDANCE_FORCE;
                    state.y += avoidanceY * AVOIDANCE_FORCE;
                }

                state.x = Math.max(state.width / 2, Math.min(worldSize - state.width / 2, state.x));
                state.y = Math.max(state.height / 2, Math.min(worldSize - state.height / 2, state.y));

                element.style.left = `${state.x - state.width / 2}px`;
                element.style.top = `${state.y - state.height / 2}px`;
                element.style.transform = `rotate(${state.angle}deg)`;

                if (state.state === 'following' && state.leader === crabState && crabState.isDancing) {
                    if(state.hasRightArm) {
                        state.domElements.rightArm.style.transform = `rotate(${crabState.rightArmAngle - state.angle}deg)`;
                        state.domElements.rightClaw.style.transform = `rotate(${crabState.rightClawAngle}deg)`;
                        state.domElements.rightClaw.style.backgroundImage = rightClawEl.style.backgroundImage;
                    }
                     if(state.hasLeftArm) {
                        state.domElements.leftArm.style.transform = `rotate(${crabState.leftArmAngle - state.angle}deg)`;
                        state.domElements.leftClaw.style.transform = `rotate(${crabState.leftClawAngle}deg)`;
                        state.domElements.leftClaw.style.backgroundImage = leftClawEl.style.backgroundImage;
                    }
                } else if (state.state === 'warrior') {
                    if (state.isAttacking && state.attackArm) {
                        state.attackTimer -= deltaTime;
                        let progress = 0;
                        const armEl = state.domElements[state.attackArm + 'Arm'];
                        const clawEl = state.domElements[state.attackArm + 'Claw'];
                        const otherArm = state.attackArm === 'left' ? 'right' : 'left';
                        if(state['has' + (otherArm.charAt(0).toUpperCase() + otherArm.slice(1)) + 'Arm']) {
                            const otherArmEl = state.domElements[otherArm + 'Arm'];
                            const otherClawEl = state.domElements[otherArm + 'Claw'];
                            const defaultAngle = otherArm === 'left' ? 45 : -45;
                            otherArmEl.style.transform = `rotate(${defaultAngle}deg)`;
                            otherClawEl.style.transform = `rotate(0deg)`;
                        }

                        switch(state.attackPhase) {
                            case 'windup':
                                if (state.attackTimer <= 0) {
                                    state.attackPhase = 'lunge';
                                    state.attackTimer = 500;
                                    state.initialAttackAngles = state.targetAttackAngles;
                                    const targetState = state.targetCrab;
                                    const targetLimb = state.targetLimb;
                                    if(!targetState || !targetState['has' + (targetLimb.charAt(0).toUpperCase() + targetLimb.slice(1)) + 'Arm']) {
                                        state.isAttacking = false; state.attackPhase = 'none'; break;
                                    }
                                    const targetAngleRad = targetState.angle * (Math.PI / 180);
                                    const cosTarget = Math.cos(targetAngleRad);
                                    const sinTarget = Math.sin(targetAngleRad);
                                    const armPivotOffsetY = 170 - targetState.height / 2;
                                    const pivotOffsetX = targetLimb === 'left' ? (200 + 57/2) - targetState.width/2 : (25 + 57/2) - targetState.width/2;
                                    const shoulderX = targetState.x + (pivotOffsetX * cosTarget - armPivotOffsetY * sinTarget);
                                    const shoulderY = targetState.y + (pivotOffsetX * sinTarget + armPivotOffsetY * cosTarget);
                                    const armWorldAngleRad = targetState[targetLimb + 'ArmAngle'] * (Math.PI / 180);
                                    const wristX = shoulderX + ARM_LENGTH * Math.cos(armWorldAngleRad);
                                    const wristY = shoulderY + ARM_LENGTH * Math.sin(armWorldAngleRad);
                                    const warriorAngleRad = state.angle * (Math.PI / 180);
                                    const cosWarrior = Math.cos(warriorAngleRad);
                                    const sinWarrior = Math.sin(warriorAngleRad);
                                    const warriorPivotOffsetY = 170 - state.height / 2;
                                    const warriorPivotOffsetX = state.attackArm === 'left' ? (200 + 57/2) - state.width/2 : (25 + 57/2) - state.width/2;
                                    const screenCenterX = window.innerWidth / 2;
                                    const screenCenterY = window.innerHeight / 2;
                                    const targetWristScreenX = (wristX - crabState.x) * camera.zoom + screenCenterX;
                                    const targetWristScreenY = (wristY - crabState.y) * camera.zoom + screenCenterY;
                                    const warriorShoulderWorldX = state.x + (warriorPivotOffsetX * cosWarrior - warriorPivotOffsetY * sinWarrior);
                                    const warriorShoulderWorldY = state.y + (warriorPivotOffsetX * sinWarrior + warriorPivotOffsetY * cosWarrior);
                                    const warriorShoulderScreenX = (warriorShoulderWorldX - crabState.x) * camera.zoom + screenCenterX;
                                    const warriorShoulderScreenY = (warriorShoulderWorldY - crabState.y) * camera.zoom + screenCenterY;
                                    const { armAngleRad, clawAngleRad } = solveIK(warriorShoulderScreenX, warriorShoulderScreenY, targetWristScreenX, targetWristScreenY, ARM_LENGTH * camera.zoom, CLAW_EFFECTIVE_LENGTH * camera.zoom, state.attackArm === 'left');
                                    const armWorldAngleDeg = armAngleRad * (180 / Math.PI) - 90;
                                    const internalAngleRad = state.attackArm === 'left' ? LEFT_CLAW_INTERNAL_ANGLE_RAD : RIGHT_CLAW_INTERNAL_ANGLE_RAD;
                                    const clawWorldAngleDeg = (clawAngleRad - internalAngleRad) * (180 / Math.PI);
                                    state.targetAttackAngles = { arm: armWorldAngleDeg, claw: clawWorldAngleDeg - armWorldAngleDeg };
                                }
                                break;
                            case 'lunge':
                                progress = 1 - (state.attackTimer / 500);
                                const lungeArmAngle = state.initialAttackAngles.arm + (state.targetAttackAngles.arm - state.initialAttackAngles.arm) * progress;
                                const lungeClawAngle = state.initialAttackAngles.claw + (state.targetAttackAngles.claw - state.initialAttackAngles.claw) * progress;
                                armEl.style.transform = `rotate(${lungeArmAngle - state.angle}deg)`;
                                clawEl.style.transform = `rotate(${lungeClawAngle}deg)`;
                                const attackerClawBox = getAbsoluteBoundingBox(clawEl);
                                const targetCrabObject = state.targetCrab === crabState ? {state: crabState} : pilgrims.find(p => p.state === state.targetCrab);
                                const targetArmEl = targetCrabObject?.state.domElements[state.targetLimb + 'Arm'];
                                if(targetArmEl) {
                                    const targetArmBox = getAbsoluteBoundingBox(targetArmEl);
                                    if(checkAABBCollision(attackerClawBox, targetArmBox)) {
                                         detachLimb(targetCrabObject, state.targetLimb);
                                         state.attackPhase = 'retract'; 
                                         state.attackTimer = 300;
                                         state.initialAttackAngles = { arm: lungeArmAngle, claw: lungeClawAngle };
                                         const baseArmAngle = state.attackArm === 'left' ? 45 : -45;
                                         state.targetAttackAngles = { arm: state.angle + baseArmAngle, claw: 0 };
                                    }
                                }
                                if (state.attackTimer <= 0) {
                                    state.attackPhase = 'retract';
                                    state.attackTimer = 300;
                                    state.initialAttackAngles = state.targetAttackAngles;
                                    const baseArmAngle = state.attackArm === 'left' ? 45 : -45;
                                    state.targetAttackAngles = { arm: state.angle + baseArmAngle, claw: 0 };
                                }
                                break;
                            case 'retract':
                                progress = 1 - (state.attackTimer / 300);
                                const retractArmAngle = state.initialAttackAngles.arm + (state.targetAttackAngles.arm - state.initialAttackAngles.arm) * progress;
                                const retractClawAngle = state.initialAttackAngles.claw + (state.targetAttackAngles.claw - state.initialAttackAngles.claw) * progress;
                                armEl.style.transform = `rotate(${retractArmAngle - state.angle}deg)`;
                                clawEl.style.transform = `rotate(${retractClawAngle}deg)`;
                                if (state.attackTimer <= 0) {
                                    state.isAttacking = false;
                                    state.attackPhase = 'none';
                                }
                                break;
                        }

                        if(state.attackPhase === 'windup') {
                            progress = 1 - (state.attackTimer / 200);
                            const currentArmAngle = state.initialAttackAngles.arm + (state.targetAttackAngles.arm - state.initialAttackAngles.arm) * progress;
                            armEl.style.transform = `rotate(${currentArmAngle}deg)`;
                        }
                    } else {
                        if(state.hasLeftArm) {
                            state.domElements.leftArm.style.transform = `rotate(45deg)`;
                            state.domElements.leftClaw.style.transform = `rotate(0deg)`;
                        }
                         if(state.hasRightArm){
                            state.domElements.rightClaw.style.backgroundImage = `url('${imageUrls.rightOpen}')`;
                            state.domElements.rightArm.style.transform = `rotate(-45deg)`;
                            state.domElements.rightClaw.style.transform = `rotate(0deg)`;
                        }
                    }
                }
                else {
                    updatePilgrimClaws(pilgrim);
                }
            }

            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>